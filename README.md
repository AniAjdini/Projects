#  <center>Spatiotemporal Analysis in Spark & Hadoop</center>

# <center>  Εισαγωγή</center>

Σε αυτή την έρευνα παρουσιάζεται ένα σύστημα για την παρακολούθηση της θαλάσσιας δραστηριότητας βάσει των θέσεων των πλοίων που πλέουν στη θάλασσα. Γενικά η ανίχνευση τέτοιων δεδομένων γίνεται και επικεντρώνεται στις σημαντικές αλλαγές πορείας του κάθε σκάφους στο πέρασμα του χρόνου και έτσι μπορούμε να κρατήσουμε ιστορικά δεδομένα για την πρόσφατη κίνηση των πλοίων. Επιπλέον, χάρη στην αναγνώριση σύνθετων γεγονότων, αυτό το σύστημα μπορεί επίσης να προσφέρει άμεση ειδοποίηση σε περίπτωση θαλάσσιας κατάστασης έκτακτης ανάγκης, όπως ο κίνδυνος των συγκρούσεων, ύποπτες κινήσεις σε προστατευόμενες ζώνες, ή ανταλλαγή παράνομων φορτίων στην ανοιχτή θάλασσα. Τα δεδομένα τα οποία θα ασχοληθούμε είναι χωροχρονικά όπως αναφέραμε αλλά και γεωγραφικά. Η ερεύνα μας θα εστιάσει στην παρακολούθηση αλιευτικών πλοίων που βρίσκονται εντος απαγορευμένων αλιευτικών χώρων. Θα γίνει μια ανάλυση χρονολογικής σειράς, η οποία θα μελετά την συχνότητα των πλοίων που είναι εντος αυτής στο βάθος του χρόνου με το μοντέλο AR( autoregressive ). Τέλος θα εκτελέσουμε τον αλγόριθμο ομαδοποίησης K-means για τα αλιεύτηκα πλοία εντος των επιτρεπομένων περιοχών αλίευσης. Για τον λόγο ότι ο όγκος των δεδομένων που έχουμε είναι τεράστιος και δύσκολα επεξεργάσιμος χρησιμοποιήσαμε εργαλεία οπού προσφέρονται για την ανάλυση μεγάλης κλίμακας δεδομένων όπως είναι το Hdfs για την παράλληλη αποθήκευση των δεδομένων σε cluster υπολογιστών καθώς και το Spark για την γρήγορη επεξεργασίας μεγάλης κλίμακας παράλληλων δεδομένων.

# <center> Περιγραφή Δεδομένων </center>

Τα δεδομένα τα όποια έχουμε χρησιμοποιήσει παρέχονται από την ιστοσελίδα του zenodo ( Heterogeneous Integrated Dataset for Maritime Intelligence, Surveillance, and Reconnaissance ) και χρονικά αναφέρονται για το εξάμηνο 2015-10-01 έως 2016-03-31. Η συγκεκριμένη ιστοσελίδα είχε πολλά data sets τα όποια αφορούν δεδομένα κινούμενων πλοίων, περιβάλλοντος (μετεωρολογικά), γεωγραφικά δεδομένα καθώς και άλλα. Από όλα αυτά τα σύνολα δεδομένων στην παρούσα εργασία θα χρησιμοποιήσουμε τα εξής :
<ol>
<li> [P1] AIS Data (nari_dynamic .csv, nari_static.csv ) </li>
<li> [P1] AIS Status Codes and Types</li>
<li>[C5] Fishing Constraints</li>
<li> [C4] Fishing Areas (European commission)</li>
</ol>

<h1></h1>
1.Για το τα δεδομένα [P1] AIS Data - nari_dynamic έχουμε

<ul>
<li>Sourcemmsi : Είναι το μοναδικό id κάθε πλοίου</li>
<li>Navigationalstatus : Ακέραιος αριθμός που αναφέρετε στην κατάσταση του πλοίου</li>
<li>Speedoverground : Ταχύτητα του πλοίου σε κόμβους</li>
<li>Lon : Είναι το γεωγραφικό μήκος</li>
<li>Lat : Είναι το γεωγραφικό πλάτος</li>
<li>t : χρόνος σε epoch/unix timestamp</li></ul>

<h1></h1>

2. Για το τα δεδομένα [P1] AIS Data - nari_static έχουμε
<ul>
<li>Sourcemmsi : Το μοναδικό id κάθε πλοίου </li>
<li>shipname : Το όνομα του πλοίου</li>
<li>shiptype : Ο τύπος του πλοίου </li>
<li>t : χρόνος σε epoch/unix timestamp</li> </ul>

<h1></h1>

3. Για το τα δεδομένα [P1] AIS Status Codes and Types έχουμε
<ul>
<li>Shiptype(min,max) : Ο αριθμός που αντιστοιχεί στον τύπο του πλοίου.</li> 
<li>Ais_type_summary : Η ονομασία του τύπο των πλοίων.</li> </ul>
 
 <h1></h1>
 
4. Για το τα δεδομένα [C5] Fishing Constraints έχουμε
<ul>
<li>Geometry : Περιέχει τα πολύγωνα ‘’points’’ των 2 περιοχών</li>
<li>Geoid : Περιέχει την αρίθμηση των περιοχών δηλαδή πρώτη περιοχή=0 και η δεύτερη = 1</li> </ul>

<h1></h1>
<p>Εικονα 1: Τα δυο πολύγωνα που περιέχει το [C5] Fishing Constraints</p>
<img src="https://github.com/AniAjdini/Spatiotemporal-Analysis/blob/master/photos/perioxew%20ston%20xarti.png" alt=""  width="500" height="350" class="center">

<h1></h1>

5. Για το τα δεδομένα [C4] Fishing Areas (European commission) έχουμε
<ul>
<li>Name : Το όνομα του κάθε πολυγώνου (Σε όλα είναι BREST)</li> 
<li>maxLat, maxLong, minLat, minLong : Είναι τα bounds του ενιαίου πολυγώνου</li> 
<li>geometry : Περιέχει τα πολύγωνα ‘’points’’ των 2 περιοχών</li> 
<li>geoid : Περιέχει την αρίθμηση των περιοχών</li> </ul>

<h1></h1>

# <center>  Περιγραφή Εργαλείων Που Χρησιμοποιηθήκαν </center>
Ο Μεγάλος όγκος δεδομένων προκάλεσε τεράστια αλλαγή στα εργαλεία όπου χρησιμοποιούνται για την αποθήκευση και την ανάλυση δεδομένων. Μια γλωσσά προγραμματισμού εγκατεστημένη σε έναν υπολογιστή δεν είναι ικανή να τα φέρει εις πέρας σε ένα Big Data πρόβλημα. Για την επίλυση αυτού το προβλήματος έχει δημιουργηθεί το Spark για την επεξεργασία των δεδομένων , καθώς και το HDFS του Hadoop για την αποθήκευση . Στην συγκεκριμένη εργασία χρησιμοποιήσαμε και τα δυο αυτά εργαλεία για την υλοποίηση της ερευνά που έγινε ως προς την παράβαση αλιευτικών πλοίων εντος απαγορευμένων περιέχων. Παρακάτω γίνεται μια μικρή επισκόπηση για τα δυο αυτά εργαλεία.

# 1. Εργαλείο Επεξεργασίας δεδομένων Spark

Το Apache Spark δημιουργήθηκε με την γλώσσα προγραμματισμού Scala άλλα έχει την δυνατότητα να χρησιμοποιηθεί και με τις γλώσσες (Python, R, Java). Είναι μία γρήγορη και γενικής χρήσεως μηχανή επεξεργασίας μεγάλης κλίμακας παράλληλων δεδομένων, η οποία επεκτείνει το δημοφιλές μοντέλο MapReduce. Μπορούμε να πούμε ότι ένα από τα πιο σημαντικά χαρακτηριστικά του Spark είναι ότι λειτουργεί στην μνήμη [1]. Το γεγονός αυτό, έχει ως αποτέλεσμα να είναι πιο αποτελεσματικό σε υπολογισμούς, λόγω της αποφυγής του δίσκου ανάγνωσης / εγγραφής συμφόρησης. Το έργο Spark περιέχει πολλές συνιστώσες: Spark SQL, Spark Streaming, MlLib και GraphX. Αυτές οι συνιστώσες έχουν σχεδιαστεί για να εργαστούν από κοινού, όποτε το θελήσει κανείς. Έτσι, μπορούν να συνδυαστούν σε ένα έργο λογισμικού, όπου το Spark αποτελεί τον πυρήνα τους. Τότε το SPARK είναι υπεύθυνο για τον προγραμματισμό, τη διανομή, και τις εφαρμογές παρακολούθησης ενός συμπλέγματος (cluster). Ένα από τα πιο σημαντικά εργαλεία στην Spark είναι η βιβλιοθήκη μηχανικής μάθησης . Αυτή η βιβλιοθήκη είναι μέρος του πυρήνα Spark, ως εκ τούτου μπορεί να χρησιμοποιηθεί από οποιαδήποτε άλλη από τις άλλες βιβλιοθήκες. Ο σχεδιασμός και η φιλοσοφία Mllib είναι απλή δηλαδή επιτρέπει να επικαλούνται διάφοροι αλγόριθμοι σε κατανεμημένα σύνολα δεδομένων, που αντιπροσωπεύουν όλα τα δεδομένα σε RDDs. Υλοποιήσαμε έναν αλγόριθμο (K-means) με την χρήση της βιβλιοθήκης Mllib.

# 2. Hadoop Distributed File System (HDFS)

Το σύστημα κατανομής αρχείων Hadoop (HDFS) είναι ένα κατανεμημένο σύστημα αρχείων που έχει σχεδιαστεί για να τρέχει σε όλα τα υπάρχοντα συστήματα Hardware [2]. Έχει πολλές ομοιότητες με τα υπάρχοντα κατανεμημένα συστήματα αρχείων. Ωστόσο, οι διαφορές από άλλα κατανεμημένα συστήματα αρχείων είναι σημαντικές. Το HDFS είναι εξαιρετικά ανεκτικό σε σφάλματα και έχει σχεδιαστεί για ανάπτυξη σε υλικό χαμηλού κόστους. Το HDFS παρέχει υψηλή πρόσβαση σε δεδομένα εφαρμογών και είναι κατάλληλο για εφαρμογές που έχουν μεγάλα σύνολα δεδομένων. Επίσης χαλαρώνει μερικές απαιτήσεις POSIX για να επιτρέψει τη ροή δεδομένων σε δεδομένα αρχείων. Το HDFS δημιουργήθηκε αρχικά ως υποδομή για το πρόγραμμα μηχανών αναζήτησης του Apache Nutch και είναι μέρος του Apache Hadoop Core.

# 3. Γλωσσά προγραμματισμού Python - Pyspark

Ο προγραμματισμός των σύγχρονων συστημάτων μηχανικής μάθησης και cluster computing γίνεται συνήθως με Python. Ακόμη και όταν η Python δεν είναι η κύρια γλώσσα προγραμματισμού ενός τέτοιου συστήματος, υπάρχει ένα ‘Python binding’. Χαρακτηριστικό παράδειγμα είναι το Spark που, αν και το πρωτεύον API του είναι σε Scala, κυρίως χρησιμοποιείται το Python API (PySpark). Η Python είναι επίσης η γλώσσα που χρησιμοποιούν πλέον οι περισσότεροι data scientists λόγω των εκτεταμένων βιβλιοθηκών έτοιμων αλγορίθμων μηχανικής μάθησης και επεξεργασίας δεδομένων διαφορετικών μορφών και μεγεθών.

# 4. FileZilla Client

Το πρόγραμμα FileZilla Client δίνει την δυνατότητα για την μεταφορά αρχείων από έναν υπολογιστή A σε έναν άλλο μακρινό υπολογιστή B. Το συγκεκριμένο εργαλείο χρησιμοποιήθηκε για την μεταφορά όλων μας των δεδομένων που είχαμε κατεβάσει από το zenodo στο vm Master όπου είχαμε φτιάξει στον okeano

# <center> Περιγραφή της αρχιτεκτονικής </center> 

# Αρχιτεκτονική του Spark

Το Spark χρησιμοποιεί αρχιτεκτονική master/worker. Υπάρχει ένας driver που μιλάει με έναν συντονιστή που ονομάζεται master και διαχειρίζεται τους workers στους οποίους τρέχουν οι executors. Ένας master είναι ένα Spark instance που συνδέεται με έναν Cluster Manager για πόρους και αποκτά κόμβους της συστάδας για να εκτελέσει executors. Από την άλλη πλευρά, οι workers (γνωστοί και ως slaves) αποτελούν Spark instances στα οποία οι executors ζουν για να εκτελούν εργασίες. Αυτοί είναι οι υπολογιστικοί κόμβοι του Spark που επίσης επικοινωνούν μεταξύ τους χρησιμοποιώντας τα Block Manager instances που διαθέτουν [3]. Ο driver και οι executors τώρα, τρέχουν στις δικές τους Python διαδικασίες. Μπορούν να τρέξουν όλοι στην ίδια (οριζόντια συστάδα) ή σε ξεχωριστές μηχανές (κάθετη συστάδα) ή σε μικτή διαμόρφωση μηχανής. Όταν δημιουργείται ένα SparkContext, κάθε worker εκκινεί έναν executor. Οι executors συνδέονται πίσω στο πρόγραμμα του driver. Τώρα ο driver μπορεί να τους στείλει εντολές, όπως για παράδειγμα flatMap, map και reduceByKey. Όταν ο driver κλείσει, οι executors κλείνουν επίσης. Υπάρχουν τρείς διαφορετικοί τύποι cluster manager στο Apache Spark:
1. Spark-Standalone – Spark workers are registered with spark master
2. Yarn – Spark workers are registered with YARN Cluster manager.
3. Mesos – Spark workers are registered with Mesos.
Στην συγκεκριμένη εργασία θα χρησιμοποιήσαμε ως cluster manager τον δεύτερο, δηλαδή το Yarn-SPARK. Με σκοπό την υλοποίηση της εργασίας μας δημιουργήσαμε δυο VMs στον okeano με τα έξης χαρακτηριστικά :
<ul>
<li>Ubuntu Lts</li>
<li>Cpu : x8</li>
<li>Ram : 8</li>
<li>Private network</li>
<li>IPv6</li>
<li>Storage Hdd : 40 Gb</li>
</ul?>
Έπειτα κατεβάσαμε την 2.3.1 έκδοση του Spark και κάναμε τις ανάλογες ρυθμίσεις με βάση το Guide που μας δόθηκε. Τέλος ορίσαμε τον master και τους workers (slaves).
<h1></h1>
Image : Spark Architecture
<h1></h1>
<img src="https://github.com/AniAjdini/Spatiotemporal-Analysis/blob/master/photos/master%20and%20slaves.png" alt="Spark Architecture" class="center">
<h1></h1>
<h1></h1>
# Αρχιτεκτονική του Hadoop

Το HDFS είναι ένα σύστημα σχεδιασμένο για την αποθήκευση πολύ μεγάλου όγκου δεδομένων, με υποστήριξη για πρότυπα προσπέλασης σε δεδομένα συνεχούς ροής (streaming data access patterns), σε cluster απλών υπολογιστών. Υπάρχουν σήμερα συστάδες Hadoop σε λειτουργία, που αποθηκεύουν Petabytes δεδομένων. Το HDFS είναι χτισμένο γύρω από την ιδέα ότι το πιο αποτελεσματική πρότυπο επεξεργασίας δεδομένων είναι αυτό της «εγγραφής-μια φορά, ανάγνωσης-πολλές φορές» (write-once, read-multiple times). Τυπικά, ένα σύνολο δεδομένων παράγεται ή αντιγράφεται από προϋπάρχουσα πηγή, και στη συνέχεια πραγματοποιούνται διάφορες αναλύσεις σε αυτό το σύνολο δεδομένων. Κάθε ανάλυση περιλαμβάνει ένα μεγάλο μέρος, αν όχι όλο, από το σύνολο των δεδομένων. Κατά συνέπεια, ο χρόνος για την ανάγνωση ολόκληρου του συνόλου δεδομένων είναι πιο σημαντικός από τον χρόνο ανάγνωσης της πρώτης εγγραφής. Στην δική μας περίπτωση έχουμε 2 VM μηχανήματα σε κάθε cluster τα οποία βρίσκονται στον cloud του okeanos . Είναι δυο Ubuntu LTS τα οποία βρίσκονται σε private network με ΝΑΤ, σύμφωνα με τo Guide για το ένα cluster κα για το δεύτερο cluster απλά με public IPs.Στον master τρέχει ο NameNode , o Secondary NameNode, o NodeManager , o ResourceManager και έχουμε βάλει και εκεί να τρέχει και ένας DataNode. Ενώ στον slave τρέχει μόνο ο NodeManager και ο Datanode.
<h1></h1>
Image : Hdfs Architecture
<h1></h1>
<img src="https://www.mssqltips.com/tipimages2/3180_HDFS_Architecture.jpg" alt="Hdfs Architecture" class="center">
<h1></h1>
<h1></h1>



# Αποτελέσματα και Επικύρωση Αποτελεσμάτων 
Στο κεφάλαιο αυτό θα παρουσιάσουμε τα αποτελέσματα από την ανάλυση της μελέτης μας πάνω στο θέμα του εντοπισμού αλιευτικών πλοίων εντος απαγορευμένων περιοχών καθώς και την ανάλυση της χρονολογικής σειράς η οποία βασίζεται στο πλήθος των πλοίων που είναι εντος των περιοχών αυτών σε καθημερινή βάση. 
Στην Εικόνα 7.1 βλέπουμε τις δυο περιοχές οι όποιες είναι και στην Εικόνα 3.1 στο τέταρτο κεφάλαιο αλλά με την βιβλιοθήκη matplotlib.   

<h1></h1>
Εικόνα 7.1 : 
<h1></h1>
<img src="https://github.com/AniAjdini/Spatiotemporal-Analysis/blob/master/photos/perioxes.png" alt="Hdfs Architecture" class="center">
<h1></h1>
<h1></h1>

Όπως αναφέραμε και στο έβδομο κεφάλαιο , η προσέγγιση μας στο πρόβλημα του εντοπισμου αλιευτικών πλοίων εντος των περιοχών εγινε δημιουργόντας δυο νεα πολυγωνα τα οποια είναι με την προσεγγιση minimum bounding box όπως βλέπουμε στιν παρακατω Εικονα 7.2 με σκούρο κόκκινο και μπλε χρώμα στα οποία έχουμε πλεονεκτήματα αλλά και μειονεκτήματα. Τα πλεονεκτήματα είναι ότι το query που κάναμε είναι πιο γρήγορα και πιο σαφές διότι ρωτάμε ένα τα στήγματα των πλοίων είναι μεγαλύτερα ή μικρότερα από τέσσσερα σημεία , όπου τα σημεία αυτα είναι τα max και min των lat και lon των πολυγώνων.Το μειονέκτημα που έχουμε είναι ότι έχουμε και μερικά στήγματα πλοίων τα οποία δεν βρίσκονται εντός των πραγματικών πολυγώνων  και ενδεχομένως πλοία τα οποία δεν είναι εντός των περιοχών αυτων αλλα εντοπίστηκαν λόγω των καινούριων πολυγώνων 



<h1></h1>
Εικονα 7.2 : Παρακάτω βλέπουμε τα παραλληλόγραμα  του minimum bounding box
<h1></h1>
<img src="https://github.com/AniAjdini/Spatiotemporal-Analysis/blob/master/photos/perixes%20dikesmou.png" alt="Hdfs Architecture" class="center">
<h1></h1>
<h1></h1>

 


Στο Διάγραμμα 7.1 βλέπουμε με κόκκινο το πλήθος των συνολικών πλοίων  που έχουμε στο data set μας, με  πράσινο τα πλοία που είναι εντος της πρώτης απαγορευμένης περιοχής .Τέλος με μπλε είναι το πλήθος των πλοίων που βρεθήκαν εντος της δεύτερης περιοχής. 

<h1></h1>
Διάγραμμα 7.1  
<h1></h1>
<img src="https://github.com/AniAjdini/Spatiotemporal-Analysis/blob/master/photos/all%20ships%20count%20in%20area.png" alt="Hdfs Architecture" class="center">
<h1></h1>
<h1></h1>

 

Στο Διάγραμμα 7.2  βλέπουμε τα ποσοστά των διάφορων τύπου πλοίων που έχουμε στα δεδομένα μας,  οπού συνολικά τα πλοία είναι 5055 όπως φαίνεται και παραπάνω .Παρατηρούμε πως το μεγαλύτερο ποσοστό αυτών είναι τύπου Cargo και αμέσως μετά είναι Tanker .Τρίτο έρχεται σε κατάταξη τα πλοία με τα οποία θα ασχοληθούμε δηλαδή αλιεύτηκα πλοία (Fishing).


<h1></h1>
Διάγραμμα 7.2  
<h1></h1>
<img src="https://github.com/AniAjdini/Spatiotemporal-Analysis/blob/master/photos/ola%20ta%20plia.png" alt="Hdfs Architecture" class="center">
<h1></h1>
<h1></h1>
  


7.1 Πρώτη Περιοχή 


Από ότι παρατηρούμε από τον πίνακα 7.1 το σύνολο των γραμμών είναι 1.120.332 και το πλήθος των πλοίων ανέρχεται στα 474 όπως είδαμε και προηγουμένως .Στο Διάγραμμα 7.3 βλέπουμε τα ποσοστά από τους διαφόρους τύπους πλοίων που έχουμε εντος της πρώτης περιοχής 

<h1></h1>
Διάγραμμα 7.3 : Τα ποσοστά των διαφορετικών τύπων πλοίου στην πρώτη περιοχή (Βήμα 15)
<h1></h1>
<img src="https://github.com/AniAjdini/Spatiotemporal-Analysis/blob/master/photos/perixi1.png" alt="Hdfs Architecture" class="center">
<h1></h1>
<h1></h1>
 

7.2  Δεύτερη Περιοχή 

<h1></h1>
Διάγραμμα 7.4 : Τα ποσοστά των διαφορετικών τύπων πλοίου στην δεύτερη περιοχή
<h1></h1>
<img src="https://github.com/AniAjdini/Spatiotemporal-Analysis/blob/master/photos/perioxi%200.png" alt="Hdfs Architecture" class="center">
<h1></h1>
<h1></h1>
 
 
7.3 Επικύρωση αποτελεσμάτων 
Καθώς τα πλέγματα που δημιουργήσαμε γύρω από τις απαγορευμένες περιοχές αλίευσης δεν είναι οι πραγματικές, στην υποενότητα αυτή θα κάνουμε μια επικύρωση των αποτελεσμάτων μας με στόχο να βρούμε ποσά πλοία βρίσκονται πραγματικά εντος των περιοχών αυτών. Η μεθοδολογία που ακολουθήσαμε είναι : Aφού ήδη είχαμε βρει τα δεδομένα των πλοίων που ήταν εντος των περιοχών αυτών ,οπού οι πραγματικές περιοχές είναι ένα υποσύνολο των καινούριων περιοχών μας .Στην συνεχεία   μετατρέψαμε τα δεδομένα αυτά σε Pandas DataFrame και εκτελέσαμε την συνάρτηση Within η οποία μας δίνει True εάν το points στην συγκεκριμένη γραμμή είναι εντος και False εάν όχι. Αφού πλέον έχουμε τις πραγματικές γραμμές που βρίσκονται εντος, τότε γνωρίζουμε το πραγματικό πλήθος των πλοίων που βρίσκονται μέσα μέσω της συνάρτησης unique. Στα διαγράμματα 7.5 και 7.6 βλέπουμε με μπλε χρώμα το πλήθος του πραγματικού πλήθους των πλοίων εντος της κάθε μια περιοχής και με κόκκινο το πλήθος το οποία ήταν εντος του πλέγματος που δημιουργήσαμε .

<h1></h1>
Διάγραμμα 7.5: Πρώτη Περιοχή 
<h1></h1>
<img src="https://github.com/AniAjdini/Spatiotemporal-Analysis/blob/master/photos/perioxi%200%20countships.png" alt="Hdfs Architecture" class="center">
<h1></h1>
<h1></h1>


<h1></h1>
Διάγραμμα 7.6 Δεύτερη Περιοχή 
<h1></h1>
<img src="https://github.com/AniAjdini/Spatiotemporal-Analysis/blob/master/photos/perioxi%201%20countships.png" alt="Hdfs Architecture" class="center">
<h1></h1>
<h1></h1>



#  Ανάλυσης χρονολογικής σειράς  
Με  αφορμή που ασχοληθήκαμε με τις συγκεκριμένη περιοχές, ενδιαφέρον θα ήταν να δούμε στο βάθος του χρόνου το πλήθος των πλοίων που εισέρχονται εντος αυτών. Όπως υποδηλώνει το όνομα, η χρονολογική σειρά είναι μια συλλογή σημείων δεδομένων που συλλέγονται σε σταθερά χρονικά διαστήματα. Αυτά αναλύονται για να καθορίσουν τη μακροπρόθεσμη τάση έτσι ώστε να προβλέπουν το μέλλον ή να εκτελούν κάποια άλλη μορφή ανάλυσης. Αλλά αυτό που κάνει μια χρονολογική σειρά διαφορετική από  ένα κανονικό πρόβλημα παλινδρόμησης είναι τα έξης δυο: 
Είναι εξαρτημένο από το χρόνο. Έτσι, η βασική παραδοχή ενός μοντέλου γραμμικής παλινδρόμησης που οι παρατηρήσεις είναι ανεξάρτητες δεν ισχύει στην περίπτωση αυτή.
Μαζί με μια αυξανόμενη ή μειούμενη τάση, οι περισσότερες χρονολογικές σειρές  έχουν κάποια μορφή τάσεων ή εποχικότητας, δηλ. συγκεκριμένες αλλαγές τιμών σε ένα συγκεκριμένο χρονικό πλαίσιο. 
Λόγω των ιδιοτήτων ενός χρονολογικού μοντέλου , υπάρχουν διάφορα βήματα που εμπλέκονται στην ανάλυση του. Αυτό θα εξετάσουμε παρακάτω. Στην συγκεκριμένη ερευνά χρήσιμο θα ήταν να περιγράψουμε και να αναφέρουμε τα μοντέλα τα όποια θα δούμε παρακάτω.
Αυτοπαλινδρομο Υπόδειγμα
Αυτοπαλινδρομο υπόδειγμα p τάξης συμβολίζετε με AR(p) και εκφράζετε από την σχέση : 
Y_t=α_0+α_1 Y_(t-1)+α_2 Y_(t-2)+⋯+α_p Y_(t-p)+ε_t
Όπου α_ι με  i∈[0,p]  είναι η σταθεροί παράμετροι και ε_t ο όποιος μετρά τυχαία σφάλματα. Στο αυτοπαλινδονουμενο υπόδειγμα , η εξαρτώμενη μεταβλητή  Y_t παλινδρομείται στης προηγούμενες τιμές της . Η τάξη του αυτοπαλινδρονουμενου υποδείγματος συμβολίζεται με p και προσδιορίζει το μήκος της υστέρησης . 
Υπόδειγμα Κινητού Μέσου
Ένα υπόδειγμα κινητού μέσου q τάξης συμβολίζεται με MA(q) και εκφράζετε από την σχέση :
Υ_τ=ε_t-θ_1 ε_(t-1)-θ_2 ε_(t-2)-…-θ_q ε_(t-q)
Όπου θ_i με i∈[0,q] οι σταθεροί παράμετροι και ε_t  τα τυχαία σφάλματα .Στην διαδικασία κινητού μέσου η χρονολογική σειρά   Y_t  θεωρείται ότι δημιουργείται ως ένας σταθμικός μέσος τυχαίων σφαλμάτων των q προηγουμένων περιόδων .
Ένα αυτοπαλινδρομο ολοκληρωμένο υπόδειγμα κινητού μέσου  ARIMA(p,d,q) προκύπτει από τον συνδυασμό των αυτοπαλινδρομον διαδικασιών ΑR(p) και των διαδικασιών κινητού μέσου MA(q), όπου d είναι ο αριθμός των διαφόρων που απαιτούνται προκείμενου να μετατραπεί η σειρά σε στάσιμη
Αφού πλέων  έχουμε υπολογίσει το πλήθος των πλοίων που είναι εντος και των δυο περιοχών και αναφέραμε τα μοντέλα τα όποια θα χρησιμοποιηθούν, θα δούμε παρακάτω τα δυο διαγράμματα σε μορφή χρονολογικών σειρών .  


<h1></h1>
Διάγραμμα 7.7 :Δεδομένα δεύτερης περιοχής      
<h1></h1>
<img src="https://github.com/AniAjdini/Spatiotemporal-Analysis/blob/master/photos/ts0.png" alt="Hdfs Architecture" class="center">
<h1></h1>
<h1></h1>


<h1></h1>
Διάγραμμα 7.8:  Δεδομένα πρώτης περιοχής                                 
<h1></h1>
<img src="https://github.com/AniAjdini/Spatiotemporal-Analysis/blob/master/photos/ts2.png" alt="Hdfs Architecture" class="center">
<h1></h1>
<h1></h1>

  
Μια χρονολογική σειρά  είναι στάσιμη αν οι στατιστικές της ιδιότητες όπως η μέση και η διακύμανση παραμένουν σταθερές με την πάροδο του χρόνου.  Η στασιμότητα σε μοντέλα χρονολογικών σειρών είναι σημαντική διότι τα περισσότερα από τα μοντέλα αυτά λειτουργούν με την παραδοχή ότι είναι στάσιμες.  Διαισθητικά, μπορούμε να υποθέσουμε ότι εάν μια χρονολογική σειρά έχει μια συγκεκριμένη συμπεριφορά με την πάροδο του χρόνου, υπάρχει πολύ μεγάλη πιθανότητα ότι θα ακολουθήσει το ίδιο και στο μέλλον. Παρακάτω θα εκτελέσουμε μερικούς ελέγχους στασιμότητας οι όποιοι είναι οι έξης : 
Απεικόνιση Στατιστικών Στοιχείων : Σχεδιάζουμε τον κινητό μέσο όρο και τη διακύμανση για να δούμε αν διαφέρει ανάλογα με το χρόνο. Με τη μετακίνηση μέσου όρου και την διακύμανσης όπου βασικά εννοούμε ότι σε κάθε στιγμή t, θα πάρουμε το μέσο όρο και την διακύμανση του προηγούμενων  τιμών. Αλλά και πάλι αυτό είναι περισσότερο μια οπτική τεχνική.
Δοκιμή Dickey-Fuller:  Αυτή είναι μία από τις στατιστικές δοκιμές για τον έλεγχο της στασιμότητας. Εδώ η μηδενική υπόθεση είναι ότι η χρονολογική σειρά είναι μη στατική. Τα αποτελέσματα των δοκιμών περιλαμβάνουν την τιμή της στατιστικής συνάρτησης, το P-value καθώς και ορισμένα διαστήματα  εμπιστοσύνης. Εάν η «P-value» είναι μικρότερη από την «επίπεδο σημαντικότητας » το οποίο ορίζουμε εμείς , μπορούμε να απορρίψουμε τη μηδενική υπόθεση και να πούμε ότι η σειρά είναι στάσιμη. 

<h1></h1>
Διάγραμμα 7.9  : Δεύτερη περιοχή                                 
<h1></h1>
<img src="https://github.com/AniAjdini/Spatiotemporal-Analysis/blob/master/photos/ts0_ma_sd.png" alt="Hdfs Architecture" class="center">
<h1></h1>
<h1></h1>
Results of Dickey-Fuller Test:
Test Statistic -2.111879
p-value 0.239765
#Lags Used 6.000000
Number of Observations Used 153.000000
Critical Value (5%) -2.880623
Critical Value (1%) -3.473830
Critical Value (10%) -2.576945
 
<h1></h1>
Διάγραμμα 7.10 : Πρώτη περιοχή                                  
<h1></h1>
<img src="https://github.com/AniAjdini/Spatiotemporal-Analysis/blob/master/photos/ts1_ma_sd.png" alt="Hdfs Architecture" class="center">
<h1></h1>
<h1></h1>
Results of Dickey-Fuller Test:
Test Statistic -2.897765
p-value 0.045609
#Lags Used 6.000000
Number of Observations Used 153.000000
Critical Value (5%) -2.880623
Critical Value (1%) -3.473830
Critical Value (10%) -2.576945
     
Στην δεύτερη περιοχή αν και η διακύμανση της τυπικής απόκλισης είναι μικρή, ο μέσος όρος αυξάνεται με την πάροδο του χρόνου και για αυτό το λόγο η χρονολογική σειρά μας δεν είναι στάσιμη. Επίσης η τιμή του p-value είναι μεγαλύτερη  από το επίπεδο σημαντικότητας 5% που έχουμε ορίσει .Στην πρώτη περιοχή ισχύει το κριτήριο της στασιμότητας διότι το p-value είναι μικρότερο από το επίπεδο σημαντικότητας . Στη συνέχεια, θα συζητήσουμε τις τεχνικές που μπορούν να χρησιμοποιηθούν για να γίνουν τα δεδομένα της πρώτης περιοχής μια στάσιμη χρονολογική σειρά , ώστε να ισχύουν τα αποτελέσματα από της εκτίμησης του μοντέλου. 
Ένα από τα πρώτα κόλπα για τη μείωση της τάσης είναι ο μετασχηματισμός. Για παράδειγμα, στην περίπτωση αυτή μπορούμε να διαπιστώσουμε σαφώς ότι υπάρχει μια σημαντική ανοδική τάση στα δεδομένα της πρώτης περιοχής. Έτσι μπορούμε να εφαρμόσουμε μετασχηματισμό που τιμωρεί τις υψηλότερες τιμές περισσότερο από τις μικρότερες τιμές με την λογαριθμική κλίμακα.


<h1></h1>
Διάγραμμα 7.11 : Δεδομένα δεύτερες περιοχής με λογαριθμική κλίμακα 
<h1></h1>
<img src="https://github.com/AniAjdini/Spatiotemporal-Analysis/blob/master/photos/log_ts_0.png" alt="Hdfs Architecture" class="center">
<h1></h1>
<h1></h1>
 

Σε αυτή την απλούστερη περίπτωση, παρατηρούμε πως και στην λογαριθμική κλίμακα έχουμε μια ανοδική  τάση στα δεδομένα. Αλλά δεν είναι πολύ αντιληπτή η παρουσία του θορύβου. Έτσι, μπορούμε να χρησιμοποιήσουμε ορισμένες τεχνικές για να εκτιμήσουμε  την τάση και στη συνέχεια να την αφαιρέσουμε από τη σειρά. Μια μέθοδος που θα ακολουθήσουμε είναι να πάρουμε των κινητό μέσο ορό για της 10 συνολικά μέρες πίσω και μπροστά από την κάθε τιμή.

<h1></h1>
Διάγραμμα 7.12 :  Κινητός μέσος Όρος με παράμετρο 10 ημερών σε λογαριθμική κλίμακα
<h1></h1>
<img src="https://github.com/AniAjdini/Spatiotemporal-Analysis/blob/master/photos/ma_ts0_log.png" alt="Hdfs Architecture" class="center">
<h1></h1>
<h1></h1>
 

Η κόκκινη γραμμή δείχνει τον κινητό μέσο ορό. Παραιτούμε πως έχουμε μια εξομάλιση στην σειρά μας. Λαμβάνουμε  υπόψη ότι από τη στιγμή που παίρνουμε το μέσο όρο των τελευταίων 10 τιμών, ο κινητός  μέσος δεν ορίζεται για τις πρώτες 9 τιμές όπως φαίνεται και στο παραπάνω διάγραμμα. Κάνοντας όμως τον ελέγχω στασιμότητας με p-value > 5% βλέπουμε πως ούτε τώρα δεν είναι στάσιμη η χρονολογική σειρά. Μια άλλη τεχνική για να γίνει η χρονολογική σειρά στάσιμη είναι το να πάρουμε τις πρώτες διαφορές της σειράς , δηλαδή ορίζουμε ως πρώτες διαφορές  y_t^'=y_t-y_(t-1)


<h1></h1>
Διάγραμμα 7.13 : Δεδομένα με της πρώτες διαφορές σε λογαριθμική κλίμακα
<h1></h1>
<img src="https://github.com/AniAjdini/Spatiotemporal-Analysis/blob/master/photos/log_ts_diff1.png" alt="Hdfs Architecture" class="center">
<h1></h1>
<h1></h1>

 

Τα δεδομένα που περιχεί το παραπάνω διάγραμμα είναι τα δεδομένα τα όποια θα έχουμε για το μοντέλο πρόβλεψης που θα κάνουμε παρακάτω διότι η παραπάνω χρονολογική σειρά είναι στάσιμη με p-valeu < 5%. Τα δεδομένα που θα χρησιμοποιήσουμε στα μοντέλα πρόβλεψης για την δεύτερη περιοχή δεν χρίζονται μετασχηματισμό διότι ισχύουν η κανόνες στασιμότητας , επομένως θα έχουμε τα πραγματικά δεδομένα . 

Μοντέλο πρόβλεψης
Ως μοντέλο για την πρόβλεψη των τιμών αυτόν χρησιμοποιήσαμε το AR(Autoregression) .Ορίσαμε να γίνει η πρόβλεψη για της τελευταίες 30 ημέρες των δεόμενων μας . Στα παρακάτω διαγράμματα θα δούμε με μπλε γραμμή την πρόβλεψη του μοντέλου και με κόκκινη τα πραγματικά δεδομένα. 
 
<h1></h1>
Διάγραμμα 7.14                                                                    
<h1></h1>
<img src="https://github.com/AniAjdini/Spatiotemporal-Analysis/blob/master/photos/ts0pred.png" alt="Hdfs Architecture" class="center">
<h1></h1>
<h1></h1>
MSE: 0.247


<h1></h1>
Διάγραμμα 7.15                                                                    
<h1></h1>
<img src="https://github.com/AniAjdini/Spatiotemporal-Analysis/blob/master/photos/ts1pred.png" alt="Hdfs Architecture" class="center">
<h1></h1>
<h1></h1>
MSE: 22.323           
                                                                                  
7.5 K-Means 
 Με την αφορμή ότι δεν βρήκαμε κανένα αλιευτικό πλοίο να είναι εντος της περιοχής και να αλιεύει ,όπου σαν ορισμό στο ότι ένα πλοίο αλιεύει που δώσαμε προηγούμενος στην μεθοδολογία (6ο  κεφάλαιο, βήμα 17) .Αξιοσημείωτο θα ήταν να δούμε ποια είναι τα μέρη τα όποια πάνε τα αλιεύτηκα πλοία και εάν  τηρούν τον κανονισμό δηλαδή εάν πάνε στα μέρη τα όποια επιτρέπετε η αλίευση.

<h1></h1>
Εικόνα 7.8
<h1></h1>
<img src="https://github.com/AniAjdini/Spatiotemporal-Analysis/blob/master/photos/plot%20fishing%20area%20with%20points.png" alt="Hdfs Architecture" class="center">
<h1></h1>
<h1></h1>

 Στην εικόνα 7.8 παρατηρούμε πως τα αλιευτικά πλοία είναι εντος την επιτρεπομένων περιοχών ώστε να αλιεύσουν. Βλέπουμε πως δεν καλύπτονται όλες οι περιοχές και επίσης ότι διαλέγουν κατά κύριο λόγο συγκεκριμένα μέρη ώστε να αλιεύσουν και ότι είναι 3 τα μέρη αυτά (ή και περισσότερα). Με αφορμή αυτό μπούμε να κάνουμε μια ομαδοποίηση αυτών των δεδομένων με τον αλγόριθμο K-means δίνοντας ως είσοδο μόνο το γεωγραφικό μήκος και πλάτος (lon,lat). χρησιμοποιήσαμε της βιβλιοθήκης που προσφέρει το spark την MLLib για να δούμε αν  διαχωρίζει της περιοχές αυτές. Πρώτα πρέπει να βρούμε ποσά cluster θα φταίξουμε ώστε να έχουμε ένα ικανοποιητικό σφάλμα. Στην παρακάτω εικόνα βλέπουμε από 1 έως 18 cluster τα σφάλματα τα όποια θα έχουμε. Παρατηρούμε πως στα 3 cluster θα είναι ιδανικά με βάση έτσι όπως αντιλαμβανόμαστε την Εικόνα 7.8 .  Σε συνδυασμό με τα συμπέρασμα που βγάζουμε από την Εικόνα 7.9 βλέπουμε πως στα 3 cluster έχουμε αρκετά καλό σφάλμα όμως από την άλλη , με την μέθοδο του αγκώνα (δηλαδή εάν δούμε το παρακάτω διάγραμμα σαν ένα χέρι, θέλουμε το σημείο εκείνο που βλέπουμε τον αγκώνα του χεριού). Αυτό το σημείο είναι στα 5 cluster, Για τον λόγο αυτό θα κάνουμε 2 ομαδοποίησης τον ίδιον δεδομένων ώστε να συμπεράνουμε με βάση των διαχωρισμό που θα κάνει. 



<h1></h1>
Εικόνα 7.9 : Σφάλματα με βάση των αριθμό των clusters (1 έως 18)
<h1></h1>
<img src="https://github.com/AniAjdini/Spatiotemporal-Analysis/blob/master/photos/%CE%BB%CE%BB%CE%BB.png" alt="Hdfs Architecture" class="center">
<h1></h1>
<h1></h1>

 
Στις  παρακάτω εικόνες βλέπουμε των διαχωρισμό που έκανε ο αλγόριθμος k-means στον χώρο τον οποίον βρίσκονται τα δεδομένα.

<h1></h1>
Εικόνα 7.10 : Ομαδοποίηση των δεδομένων σε 3 cluster 
<h1></h1>
<img src="https://github.com/AniAjdini/Spatiotemporal-Analysis/blob/master/photos/clustering.png" alt="Hdfs Architecture" class="center">
<h1></h1>
<h1></h1>
Within 3 Cluster Sum of Squared Errors = 45359.5653539 

<h1></h1>
Εικόνα 7.11 : Ομαδοποίηση των δεδομένων σε 5 cluster 
<h1></h1>
<img src="https://github.com/AniAjdini/Spatiotemporal-Analysis/blob/master/photos/5clusters.png" alt="Hdfs Architecture" class="center">
<h1></h1>
<h1></h1>
Within 5 Cluster Sum of Squared Errors = 4113.27894032

Παρατηρούμε πως στα 5 clusters το SSE είναι αρκετά μικρότερο σε σύγκριση με τα 3 clusters τα όποια φτιάξαμε. Αυτό είναι κάτι λογικό γιατί όσο ανεβαίνει ο αριθμός των cluster μειώνετε και το SSE διότι όλα τα σημεία θα είναι αρκετά κοντά στα κέντρα των κάθε cluster. Από ότι φαίνετε καλύτερος διαχωρισμός γίνετε στα 5 clusters διότι φαίνονται πιο ξεκάθαρα οι περιοχές τις όποιες επισκέπτονται περισσότερο.


# Συμπεράσματα
 
Η ανάλυση χωροχρονικων δεδομένων είναι κάτι αρκετά δύσκολο αλλά ταυτόχρονο  αρκετά ελκυστικό. Οι τεχνολογίες με τις όποιες ασχοληθήκαμε όπως για παράδειγμα το Spark για την επεξεργασία παραλλήλων δεδομένων ήταν αρκετά ικανοποιητικές και ταυτόχρονα αποτελεσματικές για τον λόγο ότι ένας υπολογιστής από μονός του θα χρειαζόταν αρκετό χρόνο παραπάνω ώστε να υλοποιήσει όλες αυτές τις πράξεις τις όποιες κάναμε στην συγκεκριμένη ερεύνα διότι αναφερόμασταν σε μεγάλη κλίμακα δεδομένων. Επιπροσθέτως το Hdfs του Hadoop το όποιο χρησιμοποιήσαμε για την παράλληλη αποθήκευση των δεδομένων, μας εξασφάλιζε την ασφάλεια των δεδομένων μας διότι είχαμε βάλει replication 1 , όποτε και ένα από τα δυο VMs που δημιουργήσαμε στον Okeano να χάλαγε, θα είχαμε  πρόσβαση στα δεδομένα αυτά από τον άλλον. Ως συμπέρασμα στην ερεύνα που κάναμε είναι πως δεν εντοπίσαμε κάποιο πλοίο να είναι  εντος των περιοχών αυτών και να αλιεύει ή δεν έδειχνε να αλιεύει διότι υπάρχει και η περίπτωση να έχει κλείσει το μηχάνημα το όποιο στέλνει σήμα για την τοποθεσία του καθώς και για τα αλλά δεδομένα τα οποία είχαμε και αρά δεν θα μπορούσαμε να το εντοπίσουμε. Μεγάλο ενδιαφέρον είχε και η ανάλυση της χρονολογικής σειρά με την οποία ασχοληθήκαμε διότι οι εκτιμήσεις του μοντέλου ήταν αρκετά ικανοποιητικές και για τις δυο περιοχές αυτές. Η ερεύνα χρονολογικών σειρών θα είναι χρήσιμη για τα δεδομένα τέτοιου τύπου, διότι θα γνωρίζουμε με μια μικρή απόκλιση τα πλήθος των πλοίων που εισέρχονται καθημερινώς (χειμώνα, καλοκαιροί)  εντος κάποιων περιοχών(λιμένα, περιοχές αλίευσης κ.α) διότι κατά κύριο λόγο τα δρομολόγια τα όποια έχουν να κάνουν τα πλοία είναι σταθερά, όποτε εάν δούμε καμία ξαφνική πτώση ( ή άνοδο ) θα είναι θέμα ως προς μελέτη. Τέλος για τον λόγο ότι δεν βρήκαμε στο συγκριμένο data set (με τους δικούς μας ορισμούς ως προς την κατάσταση ενός πλοίου να αλιεύει) αλιεύτηκα πλοία να είναι εντος το δυο περιχέων αυτών και να αλιεύουν, εξετάσαμε την νόμιμη εκδοχή δηλαδή την εκδοχή ότι τα πλοία αυτά πάνε να αλιεύσουν στις επιτρεπόμενες περιοχές αλιείας. Αφού βεβαιωθήκαμε ότι αυτό ισχύει με τις ανάλογες εικόνες τις όποιες φτιάξαμε με βάση τα δεδομένα, παρατηρήσαμε πως δεν καλύπτονται όλοι οι επιτρεπόμενοι χώροι αλιείας καθώς και ότι 3 με 5 μέρη από όλοι αυτή την έκταση επισκέπτονται. Προσπαθήσαμε λοιπόν να ομαδοποιήσουμε αυτά τα δεδομένα με τον αλγόριθμο K-means ώστε να δούμε άμα διαχωρίζει τις περιοχές αυτές. Ως συμπέρασμα είχαμε ότι τις διαχώρισε αυτές τις περιοχές έχοντας μόνο ως είσοδο το γεωγραφικό μήκος και πλάτος. Αν και δεν είναι ο κατάλληλος αλγόριθμος για τέτοιου τύπου δεδομένων διότι ένα μεγάλο μειονέκτημα που έχει είναι πως τα cluster τα όποια φτιάχνει είναι κυκλικά (κάτι που δεν το θέλουμε σε όλες τις περιπτώσεις). Παρόλα αυτά ο διαχωρισμός των δεδομένων που έγινε ήταν ικανοποιητικός. 
